<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/////////analog variables // these you can change up //
ddevice=0; //intialize "device"
analog_width=150; //currently, its setup to be a square, with the virtual keypad being the same size, so changing JUST this changes the size of both the analog and shoot button //
analog_height=analog_width;
analog_x=view_wview-analog_width-35;
analog_y=view_hview-analog_height-35;
analog_direction=0;
analog_distance=0;
 point_x=(analog_width+analog_x)+analog_distance*(cos(analog_direction*pi/180)); // some basic starting math // yay trig //
 point_y=(analog_height+analog_y)+analog_distance*(sin(analog_direction*pi/180)); // just kidding I hate trig //
 device_used=-1; //checks for holding, even if out of 'bounds'
 analog_direction_ship=0; //for ship
 deadzone=5; //deadzone
 
 
// control_type=0; //0=touch+analog, 1=keyboard //normally 1 as default, so its always a keyboard, unless its running the android platform or iOS //I set it to 0 to show the analog, for debug reasons, for windows too
// if(os_type == os_android or os_type == os_ios){control_type=0;}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//////// Analog Stick Math ///////////


//resets analog stick
analog_distance=0;
 point_x=(analog_x+analog_width/2)+analog_distance*(cos(analog_direction*pi/180))+view_xview;
 point_y=(analog_y+analog_height/2)+analog_distance*(sin(analog_direction*pi/180))+view_yview;

//check for if the finger is still being held for the analog
 if (!device_mouse_check_button(device_used,mb_left)){
 device_used=-1;
 }
 draw_text(250,10,string(device_used));

//analog stick equations

for(ddevice=0;ddevice&lt;=4;ddevice+=1){
 if (device_mouse_check_button(ddevice,mb_left) and  (device_mouse_x(ddevice)&gt;analog_x+view_xview-deadzone and device_mouse_y(ddevice)&gt;analog_y+view_yview-deadzone and device_mouse_x(ddevice)&lt;analog_x+analog_width+view_xview+deadzone and device_mouse_y(ddevice)&lt;analog_y+analog_height+view_yview+deadzone) or device_used=ddevice){
 device_used=ddevice;
 //math behind distance and direction
 analog_direction = radtodeg(arctan2((device_mouse_y(ddevice)-(analog_y+view_yview+analog_height/2)),(device_mouse_x(ddevice)-(analog_x+view_xview+analog_width/2)+.000001)));
   analog_direction_ship = radtodeg(arctan2(-(device_mouse_y(ddevice)-(analog_y+view_yview+analog_height/2)),(device_mouse_x(ddevice)-(analog_x+view_xview+analog_width/2)+.000001)));
 analog_distance = sqrt(sqr(device_mouse_x(ddevice)-(analog_x+view_xview+analog_width/2))+sqr(device_mouse_y(ddevice)-(analog_y+view_yview+analog_height/2)));;

 //sets deadzone for the analog stick
 if(analog_distance&gt;analog_width/2){analog_distance=analog_width/2;}
 if(analog_distance&lt;-analog_width/2){analog_distance=analog_width/2;}
 
 //points where the stick is
 point_x=(analog_x+analog_width/2)+analog_distance*(cos(analog_direction*pi/180))+view_xview;
 point_y=(analog_y+analog_height/2)+analog_distance*(sin(analog_direction*pi/180))+view_yview;
 
 
 /// control ship
 if(analog_distance/(analog_width/2)&gt;.1) o_Player.v_direction=analog_direction_ship;
 }

 // if(os_type==os_win32 || os_type==os_linux || os_type==os_macosx){
 // if (device_mouse_check_button(ddevice,mb_left) and  device_mouse_x(ddevice)&gt;virtual_x/2 and device_mouse_y(ddevice)&gt;virtual_y/2 and  device_mouse_x(ddevice)&lt;(virtual_x+virtual_width)*1.5 and device_mouse_y(ddevice)&lt;(virtual_y+virtual_height)*1.5){
 // event_perform(ev_keyboard,vk_space);
 //}}

}
///////////////// End Analog Stick ///////////////////////
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///// Analog Stick Drawing ///////


//draw box behind stick
draw_set_alpha(.4);
draw_set_color(c_dkgray);draw_rectangle(analog_x+view_xview,analog_y+view_yview,analog_x+analog_width+view_xview,analog_y+analog_height+view_yview,false);
draw_set_color(c_black);draw_rectangle(analog_x+view_xview,analog_y+view_yview,analog_x+analog_width+view_xview,analog_y+analog_height+view_yview,true);
draw_circle(analog_x+view_xview+analog_width/2,analog_y+view_yview+analog_height/2,analog_width/2,true);

//draw analog stick
draw_set_alpha(.7);
draw_line_width((analog_x+analog_width/2)+view_xview,(analog_y+analog_height/2)+view_yview,point_x,point_y,4);
draw_set_color(c_dkgray);draw_circle(point_x,point_y,analog_width/3,false);
draw_set_color(c_white);draw_circle(point_x,point_y,analog_width/3,true);
draw_circle(point_x,point_y,analog_width/5,true);draw_circle(point_x,point_y,analog_width/10,true);
////////////////// End Analog Stick ///////////////////////////
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
